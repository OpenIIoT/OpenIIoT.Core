using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Symbiote.Core
{
    /// <summary>
    /// Defines the return result of an operation.
    /// </summary>
    public enum OperationResultCode
    {
        /// <summary>
        /// The default return type.
        /// </summary>
        Unknown,
        /// <summary>
        /// The operation succeeded.
        /// </summary>
        Success,
        /// <summary>
        /// The operation encountered recoverable issues but ultimately succeeded.
        /// </summary>
        Warning,
        /// <summary>
        /// The operation encountered unrecoverable errors and did not succeed.
        /// </summary>
        Failure
    }

    /// <summary>
    /// Defines the message type for an operation message.
    /// </summary>
    public enum OperationResultMessageType
    {
        /// <summary>
        /// The default return type.
        /// </summary>
        Unknown,
        /// <summary>
        /// The message is informational only.
        /// </summary>
        Info,
        /// <summary>
        /// The message represents a recoverable issue.
        /// </summary>
        Warning,
        /// <summary>
        /// The message represents an uncoverable error.
        /// </summary>
        Error
    }

    /// <summary>
    /// Encapsulates messages generated by Operations.
    /// </summary>
    public class OperationResultMessage
    {
        /// <summary>
        /// The type of the message.
        /// </summary>
        public OperationResultMessageType Type { get; set; }

        /// <summary>
        /// The message.
        /// </summary>
        public string Message { get; set; }

        /// <summary>
        /// Constructs a message of the optionally supplied type with the optionally supplied message.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="message"></param>
        public OperationResultMessage(OperationResultMessageType type = OperationResultMessageType.Info, string message = "")
        {
            Type = type;
            Message = message;
        }

        /// <summary>
        /// Returns a formatted string representation of the message
        /// </summary>
        /// <returns>The formatted message string.</returns>
        public override string ToString()
        {
            return "[" + Type.ToString().ToUpper() + "] " + Message;
        }
    }

    public class OperationResult
    {
        public OperationResultCode ResultCode { get; set; }
        public List<OperationResultMessage> Messages { get; set; }

        public OperationResult()
        {
            ResultCode = OperationResultCode.Success;
            Messages = new List<OperationResultMessage>();
        }

        public virtual OperationResult AddInfo(string message)
        {
            Messages.Add(new OperationResultMessage(OperationResultMessageType.Info, message));
            return this;
        }

        public virtual OperationResult AddWarning(string message)
        {
            Messages.Add(new OperationResultMessage(OperationResultMessageType.Warning, message));
            ResultCode = OperationResultCode.Warning;
            return this;
        }

        public virtual OperationResult AddError(string message)
        {
            Messages.Add(new OperationResultMessage(OperationResultMessageType.Error, message));
            ResultCode = OperationResultCode.Failure;
            return this;
        }

        /// <summary>
        /// Logs the supplied message to the supplied logger with the supplied logging level
        /// </summary>
        /// <param name="logger">The logger to log the message to.</param>
        /// <param name="logLevel">The logging level to apply to the message.</param>
        /// <param name="message">The message.</param>
        /// <remarks>The accessibility for this method is set to private as there is no use case for this beyond the support of the other logging methods in this class.</remarks>
        private void Log(NLog.Logger logger, string logLevel = "Info", string message = "")
        {
            try
            {
                MethodInfo foundMethod = typeof(NLog.ILogger).GetMethod(logLevel, new[] { typeof(string) });

                if (foundMethod != null)
                    foundMethod.Invoke(logger, new object[] { message });
                else
                    logger.Error("OperationResult.Log() was unable to find the logging level method '" + logLevel + "' in the supplied logger.");
            }
            catch (Exception ex)
            {
                logger.Error("Exception thrown trying to invoke logger method '" + logLevel + "' in OperationResult.Log().");
            }

        }

        public void LogResult(NLog.Logger logger, string successLogLevel = "Info", string warningLogLevel = "Warn", string failureLogLevel = "Error")
        {
            logger.Trace("Starting print...");
            // the operation suceeded, with or without warnings
            if (ResultCode != OperationResultCode.Failure)
            {
                logger.Trace("Success...");
                Log(logger, successLogLevel, "The operation completed successfully.");


                // if any warnings were generated, print them to the logger
                if (ResultCode == OperationResultCode.Warning)
                    LogAllMessages(logger, "Trace", "The following warnings were generated during the operation:");
            }
            // the operation failed
            else
            {
                logger.Trace("Failure...");
                Log(logger, failureLogLevel, "The operation failed.");
                LogAllMessages(logger, failureLogLevel, "The following messages were generated during the operation:");
            }
        }

        public void LogAllMessages(NLog.Logger logger, string logLevel = "Info", string header = "", string footer = "")
        {
            if (header != "") Log(logger, logLevel, header);

            foreach (OperationResultMessage message in Messages)
                Log(logger, logLevel, "\t" + message.Message);

            if (footer != "") Log(logger, logLevel, footer);
        }
    }

    public class OperationResult<T> : OperationResult
    {
        public T Result { get; set; }

        public OperationResult() : base()
        {
            Result = default(T);
        }

        public virtual OperationResult<T> AddInfo(string message)
        {
            base.AddInfo(message);
            return this;
        }

        public virtual OperationResult<T> AddWarning(string message)
        {
            base.AddWarning(message);
            return this;
        }

        public virtual OperationResult<T> AddError(string message)
        {
            base.AddError(message);
            return this;
        }
    }
}
